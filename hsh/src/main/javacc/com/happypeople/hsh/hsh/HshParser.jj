options
{
	STATIC=false;
	USER_TOKEN_MANAGER=true;
    //FORCE_LA_CHECK=true;
    //LOOKAHEAD=2;
}
PARSER_BEGIN(HshParser)
package com.happypeople.hsh.hsh;
import com.happypeople.hsh.hsh.parser.*;

public class HshParser
{
	private void throwNotImplemented() {		throw new RuntimeException("not implemented");
	}
}
PARSER_END(HshParser)

//TOKEN: {
//	< TODO 		: "TODO" >

/* external defined token */
/*
	<ASSIGNMENT_WORD>
|	<IO_NUMBER>
|	<NAME>
|	<NEWLINE>
|	<WORD>
*/

//|	< WS >

/* defined token. */
/*
|	< AND_IF >
|	< BANG >
|	< CASE >
|	< CLOBBER >
|	< DLESS >
|	< DLESSDASH >
|	< DGREAT >
|	< DO >
|	< DONE >
|	< DSEMI >
|	< ELSE >
|	< ELIF >
|	< ESAC >
|	< FI >
|	< FOR >
|	< GREATAND >
|	< GREAT >
|	< IF >
|	< IN >
|	< KLAMMER_AUF >
|	< KLAMMER_ZU >
|	< LBRACE >
|	< LESS >
|	< LESSAND >
|	< LESSGREAT >
|	< OR_IF	>
|	< RBRACE >
|	< SEMICOLON >
|	< THEN >
|	< UNTIL >
|	< UPPERSANT >
|	< PIPE >
|	< WHILE >
*/
//}

/**
here_end         : WORD                      // Apply rule 3
                 ;
*/
void here_end():
{
}
{
	< WORD_3 >
	{ throw new RuntimeException("not implemented"); }
}
/**
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
*/
void io_here():
{
}
{
	( ( < DLESS > | < DLESSDASH > ) here_end() )
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}
/*
filename         : WORD                      // Apply rule 2
                 ;
*/
void filename():
{
}
{
	( < WORD_2 > )
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}
/*
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
*/
void io_file():
{
}
{
	( < LESS > | < LESSAND > | < GREAT > | < GREATAND > | < DGREAT > | < LESSGREAT > | < CLOBBER > ) filename()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
*/
void io_redirect():
{
}
{
	( < IO_NUMBER > )? ( io_file() | io_here() )
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
cmd_word         : WORD                   // Apply rule 7b
                 ;
*/
void cmd_word():
{}{
	< WORD >	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
cmd_name         : WORD                   // Apply rule 7a
                 ;
*/
L2Token cmd_name():
{
	Token ret;}{
	ret=< WORD >	{ return (L2Token)ret; }
}

/**
cmd_suffix       :            io_redirect
                 | cmd_suffix io_redirect
                 |            WORD
                 | cmd_suffix WORD
                 ;
*/
void cmd_suffix():
{}{
	( io_redirect() | < WORD > )+
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
cmd_prefix       :            io_redirect
                 | cmd_prefix io_redirect
                 |            ASSIGNMENT_WORD
                 | cmd_prefix ASSIGNMENT_WORD
                 ;
*/
void cmd_prefix():
{}{
	( io_redirect() | < ASSIGNMENT_WORD > )+	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
function_body    : compound_command                // Apply rule 9
                 | compound_command redirect_list  // Apply rule 9
                 ;
*/
void function_body():
{
}
{
	compound_command() ( redirect_list() )?
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
fname            : NAME                            // Apply rule 8
                 ;
*/
void fname():
{
}
{
	< WORD_8 >
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
function_definition : fname '(' ')' linebreak function_body
                 ;
*/
void function_definition():
{
}
{
	fname() < KLAMMER_AUF > < KLAMMER_ZU > linebreak() function_body()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
*/
void redirect_list():
{}{
	( io_redirect() )+
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
brace_group      : Lbrace compound_list Rbrace
                 ;
*/
void brace_group():
{
}
{
	< LBRACE > compound_list() < RBRACE >
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
subshell         : '(' compound_list ')'
                 ;
*/
void subshell():
{
}
{
	< KLAMMER_AUF > compound_list() < KLAMMER_ZU >
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
for_clause       : For name linebreak                            do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
*/
void for_clause():
{
}
{
//	< FOR > name() linebreak() < IN > ( ( wordlist() )? sequential_sep() )? do_group()
	< FOR > name() linebreak() < IN > ( (< WORD >)* sequential_sep() )? do_group()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
sequential_sep   : ';' linebreak
                 | newline_list
                 ;
*/
void sequential_sep():
{
}
{
	( < SEMICOLON > | < NEWLINE > ) ( <NEWLINE> )*
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
wordlist         : wordlist WORD
                 |          WORD
                 ;
*/
void wordlist():
{
}
{
	( < WORD > )+
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
name             : NAME                     // Apply rule 5
                 ;
*/
void name():
{
}
{
	< NAME5 >
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
*/
void case_list_ns():
{
}
{
	( case_item_ns() )+
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
pattern          :             WORD         // Apply rule 4
                 | pattern '|' WORD         // Do not apply rule 4
                 ;
*/
void pattern():
{
}
{
	< WORD4 > ( < PIPE > < WORD > )*
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
case_item_ns     :     pattern ')'               linebreak
                 |     pattern ')' compound_list linebreak
                 | '(' pattern ')'               linebreak
                 | '(' pattern ')' compound_list linebreak
                 ;
*/
void case_item_ns():
{
}
{
// TODO javacc crash
//	( < KLAMMER_AUF > )? pattern() < KLAMMER_ZU > ( compound_list() )? linebreak() 
	( < KLAMMER_AUF > )? pattern() < KLAMMER_ZU > linebreak() 
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
*/
void case_item():
{
}
{
	/* compound_list() and linebreak() both may start with < NEWLINE > */
// TODO javacc crash
//	( < KLAMMER_AUF > )? pattern() < KLAMMER_ZU > ( LOOKAHEAD(compound_list()) compound_list() | linebreak() ) < DSEMI > linebreak()
	( < KLAMMER_AUF > )? pattern() < KLAMMER_ZU > compound_list() < DSEMI > linebreak()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
case_list        : case_list case_item
                 |           case_item
                 ;
*/
void case_list():
{
}
{
	( case_item() )+
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac 
                 | Case WORD linebreak in linebreak              Esac
                 ;
*/
void case_clause():
{
}
{
// TODO javacc crash
//	< CASE > < WORD > linebreak() < IN > linebreak() ( case_list() | case_list_ns() )? < ESAC >
	< CASE > < WORD > linebreak() < IN > linebreak() ( case_list() )? < ESAC >
			/* lookahead to case_item works since case_list() is a list of case_item() */
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
*/
void if_clause():
{
}
{
	< IF > compound_list() < THEN > compound_list() ( else_part() )? < FI >
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
else_part        : Elif compound_list Then else_part
                 | Else compound_list
                 ;
*/
void else_part():
{
}
{
	< ELIF > compound_list() < THEN > else_part()
| 	< ELSE > compound_list()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
while_clause     : While compound_list do_group
                 ;
*/
void while_clause():
{
}
{
	< WHILE > compound_list() do_group()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
until_clause     : Until compound_list do_group
                 ;
*/
void until_clause():
{
}
{
	< UNTIL > compound_list() do_group()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
do_group         : Do compound_list Done           // Apply rule 6
                 ;
*/
void do_group():
{
}
{
	< DO > compound_list() < DONE >
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
compound_list    :              term
                 | newline_list term
                 |              term separator
                 | newline_list term separator
                 ;
*/
void compound_list():
{
}
{
	( newline_list() )? term() ( separator() )?
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
term             : term separator and_or
                 |                and_or
                 ;
*/
void term():
{
}
{
	and_or() ( LOOKAHEAD(separator()) separator() and_or() )*
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}

/**
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
*/
void compound_command():
{
}
{
	brace_group() | subshell() | for_clause() | case_clause() | if_clause() | while_clause() | until_clause()
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}
/**
simple_command   : cmd_prefix cmd_word cmd_suffix
                 | cmd_prefix cmd_word
                 | cmd_prefix
                 | cmd_name cmd_suffix
                 | cmd_name
                 ;
*/
SimpleCommand simple_command():
{
	SimpleCommand simpleCommand=new SimpleCommand();
	L2Token cmdName;}
{
	cmd_prefix() { throwNotImplemented(); } ( cmd_word() ( cmd_suffix())? )?
|	cmdName=cmd_name() ( cmd_suffix() { throwNotImplemented(); })?	{
		simpleCommand.setCmdName(cmdName);
	 	return simpleCommand;
	}
}

/** separator_op     : '&' | ';'
*/
Separator_opNode separator_op():
{	Separator_opNode ret=new Separator_opNode();
	Token t;
}
{	t=< UPPERSANT > { ret.setToken(t); }
|	t=< SEMICOLON > { ret.setToken(t); }
	{ return ret; }}
/**
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
*/
PipeSequence pipeline():
{	HshParserRules.applyRule7a(getToken(0));
	PipeSequence ret;
}
{
	( ret=pipe_sequence()
|	< BANG > ret=pipe_sequence() { ret.setBanged(true); } )	{ return ret; }
}
/**
pipe_sequence    :                             command
                 | pipe_sequence '|' linebreak command
                 ;
*/
PipeSequence pipe_sequence():
{
	PipeSequence ret=new PipeSequence();
	L2Node cmd;}
{	cmd=command() { ret.addChild(cmd); } ( < PIPE > linebreak() command() { throwNotImplemented(); } )*
	{ return ret; }
}
/**
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
*/
Command command():
{
	Command ret=new Command();
	L2Node simpleCommand;
}
{
	( LOOKAHEAD(2)
	simpleCommand=simple_command() { ret.addChild(simpleCommand); }
|	compound_command() ( redirect_list() )? { throwNotImplemented(); }
|	function_definition() { throwNotImplemented(); } )
	{ return ret; }
}
/*
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
*/
void newline_list():
{
}
{
	( < NEWLINE > )+
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}
/**
linebreak        : newline_list
                 | // empty
                 ;
*/
void linebreak():
{
}
{
	( < NEWLINE > )*
	{ throw new RuntimeException("not implemented"); /* return ret;*/ }
}
/**
and_or           :                         pipeline
                 | and_or AND_IF linebreak pipeline
                 | and_or OR_IF  linebreak pipeline
                 ;
*/
And_orNode and_or():
{
	And_orNode ret=new And_orNode();
	L2Node pipeline;
	Token t;
}
{
	( pipeline=pipeline() { ret.addChild(pipeline); }
		( ( t=< AND_IF > | t=< OR_IF > ) { ret.addChild((L2Token)t); } linebreak()
		pipeline=pipeline()		{ ret.addChild(pipeline); } )* )
	{ return ret; }
}
/** separator	: separator_op linebreak
 * 				| newline_list
 * ;
 */
SeparatorNode separator():
{
	SeparatorNode ret=new SeparatorNode();
	Separator_opNode separator_opN;
}
{
	separator_opN=separator_op() linebreak() {
		ret.addChild(separator_opN);
	}
|	newline_list() { }
	{ return ret; }
}
	
/** list 	:		list separator_op and_or
*				|	and_or ;
*/
ListNode list():
{
	ListNode ret=new ListNode();
	Separator_opNode separator_opN;
	And_orNode and_orN;
}
{
	and_orN=and_or() { ret.addChild(and_orN); }
	( LOOKAHEAD(separator_op()) separator_opN=separator_op() and_orN=and_or() {
		ret.addChild(separator_opN);
		ret.addChild(and_orN); } )*
		
	{ return ret; }
}

/** complete_command :		list separator
*                 		|	list ;
*/
CompleteCommand complete_command():
{
	final CompleteCommand cc=new CompleteCommand();
	ListNode listN;
	SeparatorNode separatorN;

}
{
    ( listN=list() { cc.setList(listN); } ( separatorN=separator() { cc.setSeparator(separatorN); } )? )
    { return cc; }
}